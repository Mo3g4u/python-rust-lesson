// ジェネリクスを使ってaddを定義
fn add<T: std::ops::Add<Output = T>>(a: T, b: T) -> T {
    a + b
}

// 関数を使ってみる
fn main() {
    println!("{}", add(10, 25));
    println!("{}", add(10.0, 25.0));
    println!("{}", add::<i32>(10, 25)); // 型を明示する時

    //println!("{}", add('a', 'a'));
}

/*
[書式] ジェネリクスで関数定義
fn 関数名 <T: トレイト> (引数1: T, 引数2: T, ...) -> 戻り値の型 {
    ...
}

std::ops::Add<Output = T>の意味
std 標準ライブラリ
std::ops オーバーロード可能な演算子のトレイトを定義したモジュール
std::ops::Add 足し算を表すトレイト
ジェネリクスで指定可能な型に、std::ops::Addトレイトを指定したということは、
このジェネリクスには「足し算を実装している型」を指定できるという意味になる。
i32やf32は足し算が可能な型だが、char型同士は足し算できないのでエラーになる


トレイト境界
ジェネリクスの型に対してトレイトを指定することを「トレイト境界（trait bound）」と呼びます。
そもそも、どんな型でも指定できるはずのジェネリクス型にトレイトを指定するということは、
「指定のトレイトを実装すべきである」という制約を課すもの。
*/
